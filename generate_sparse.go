package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"

	"golang.org/x/tools/imports"
)

var disclaimer string = `// Code generated by go; DO NOT EDIT. If this struct needs updating then
// do not update this file.  Instead, run ` + "`make`" + `
// NOTE: this will update *ALL* structs
`

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintln(os.Stderr, "Usage: generate_sparse <Struct Name> <In File Name>")
		os.Exit(1)
	}

	structName := os.Args[1]
	fileName := os.Args[2]

	fileSrc, err := os.ReadFile(fileName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to open ./pkg%s: %s\n", fileName, err)
		os.Exit(1)
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "./pkg"+fileName, string(fileSrc), 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse./pkg%s: %s\n", fileName, err)
		os.Exit(1)
	}

	for _, node := range file.Decls {
		switch node.(type) {
		case *ast.GenDecl:
			genDecl := node.(*ast.GenDecl)
			for _, spec := range genDecl.Specs {
				switch spec.(type) {
				case *ast.TypeSpec:
					typeSpec := spec.(*ast.TypeSpec)

					if typeSpec.Name.Name != structName {
						continue
					}

					switch typeSpec.Type.(type) {
					case *ast.StructType:
						structType := typeSpec.Type.(*ast.StructType)
						sparseSrc := fmt.Sprintf("package quickbooks\n%s\ntype %sSparse struct {\n", disclaimer, structName)
						for _, field := range structType.Fields.List {
							var i *ast.Ident
							var fieldType string
							if j, ok := field.Type.(*ast.Ident); ok {
								i = j
								if i.Name[0] == strings.ToUpper(i.Name)[0] && i.Name != "RefreshToken" {
									fieldType = i.Name + "Sparse"
								} else {
									fieldType = i.Name
								}
							} else if j, ok := field.Type.(*ast.StarExpr); ok {
								switch ds := j.X.(type) {
								case *ast.SelectorExpr:
									i = ds.Sel
								case *ast.Ident:
									i = ds
								}
								if i.Name[0] == strings.ToUpper(i.Name)[0] && i.Name != "RefreshToken" {
									fieldType = "*" + i.Name + "Sparse"
								} else {
									fieldType = "*" + i.Name
								}
							}

							for _, name := range field.Names {
								fieldName := name.Name
								sparseStr := "`json:\",omitempty\"`"
								if fieldName == "Id" || fieldName == "SyncToken" {
									sparseStr = ""
								}
								sparseSrc += fmt.Sprintf("    %s %s %s\n", fieldName, fieldType, sparseStr)
							}
						}
						sparseSrc += "}\n"
						out, err := imports.Process("enums.go", []byte(sparseSrc), &imports.Options{
							Comments: true,
						})
						if err != nil {
							fmt.Fprintf(os.Stderr, "Error linting: %s\n%s", err, sparseSrc)
							os.Exit(1)
						}

						outName := fileName[:len(fileName)-3]
						fn, err := os.Create(fmt.Sprintf("%s_sparse.go", outName))
						if err != nil {
							fmt.Fprintf(os.Stderr, "Failed to write to %s_sparse.go: %s\n", outName, err)
							os.Exit(1)
						}
						defer fn.Close()
						fn.Write([]byte(out))
					}
				}
			}
		}
	}
}
